# PRP: Template Engine Integration

## Overview
Integrate a template engine (Handlebars) to power code generation, documentation, and customizable outputs. This provides the foundation for generating boilerplate code and project structures.

## Context and Background
Template engines allow separation of logic from presentation. Handlebars is chosen for its simplicity, wide adoption, and good Rust support. Templates will be filesystem-based for easy customization.

### Research References
- Handlebars-rust: https://docs.rs/handlebars/latest/handlebars/
- Template syntax: https://handlebarsjs.com/guide/
- Helper functions: https://docs.rs/handlebars/latest/handlebars/struct.Handlebars.html#method.register_helper
- Performance considerations: https://github.com/sunng87/handlebars-rust#performance

## Requirements

### Primary Goals
1. Integrate Handlebars engine with custom helpers
2. Create template loading and caching system
3. Implement template validation
4. Build context data structures for templates
5. Support template inheritance and partials

### Technical Constraints
- Templates must be filesystem-based
- Support hot-reload in development
- Maintain template versioning
- Handle missing variables gracefully
- Keep templates human-readable

## Implementation Blueprint

### File Structure
```
src/
├── template/
│   ├── mod.rs           # Template module exports
│   ├── engine.rs        # Handlebars engine wrapper
│   ├── loader.rs        # Template loading/caching
│   ├── helpers/         # Custom helper functions
│   │   ├── mod.rs
│   │   ├── string.rs    # String manipulation helpers
│   │   ├── path.rs      # Path/filesystem helpers
│   │   └── logic.rs     # Conditional/logic helpers
│   └── context.rs       # Context builders

.auto-dev/
├── templates/
│   ├── base/            # Base templates
│   ├── code/            # Code generation templates
│   │   ├── rust/
│   │   ├── python/
│   │   └── javascript/
│   ├── docs/            # Documentation templates
│   └── partials/        # Reusable components
```

### Key Components
1. **TemplateEngine**: Wrapper around Handlebars
2. **TemplateLoader**: Loads and caches templates
3. **ContextBuilder**: Builds data for templates
4. **HelperRegistry**: Custom helper functions
5. **TemplateValidator**: Validates template syntax

### Custom Helpers to Implement
```handlebars
{{camelCase name}}           # Convert to camelCase
{{snakeCase name}}           # Convert to snake_case
{{pascalCase name}}          # Convert to PascalCase
{{kebabCase name}}           # Convert to kebab-case
{{pluralize word}}           # Pluralize word
{{indent text spaces=2}}     # Indent text
{{includeFile path}}         # Include external file
{{timestamp format="iso"}}   # Current timestamp
{{ifEmpty value default}}    # Default for empty values
```

### Implementation Tasks (in order)
1. Add handlebars to Cargo.toml with latest version
2. Create src/template module structure
3. Implement TemplateEngine wrapper
4. Create filesystem template loader
5. Add template caching with TTL
6. Implement string case conversion helpers
7. Add path and file helpers
8. Create conditional logic helpers
9. Build template inheritance system
10. Implement partial registration
11. Add template validation command
12. Create hot-reload for development

## Template Examples

### Code Generation Template
```handlebars
// {{fileName}}.rs
// Generated by auto-dev on {{timestamp}}

{{#if useAsync}}
use async_trait::async_trait;
{{/if}}

pub struct {{pascalCase structName}} {
    {{#each fields}}
    pub {{snakeCase this.name}}: {{this.type}},
    {{/each}}
}

impl {{pascalCase structName}} {
    pub fn new({{#each fields}}{{snakeCase this.name}}: {{this.type}}{{#unless @last}}, {{/unless}}{{/each}}) -> Self {
        Self {
            {{#each fields}}
            {{snakeCase this.name}},
            {{/each}}
        }
    }
}
```

### Documentation Template
```handlebars
# {{projectName}}

{{description}}

## Installation

```bash
{{installCommand}}
```

## Usage

{{#each examples}}
### {{this.title}}

```{{this.language}}
{{this.code}}
```

{{this.explanation}}
{{/each}}
```

## Context Data Structure

```rust
// Example context for templates
#[derive(Serialize)]
struct TemplateContext {
    project_name: String,
    author: String,
    language: String,
    timestamp: String,
    fields: Vec<FieldDef>,
    options: HashMap<String, Value>,
}

#[derive(Serialize)]
struct FieldDef {
    name: String,
    field_type: String,
    optional: bool,
    default: Option<String>,
}
```

## Validation Gates

```bash
# Build and test
cargo fmt --check && cargo clippy --all-targets --all-features -- -D warnings

# Test template loading
cargo test template::tests

# Validate templates
cargo run -- template validate

# Test code generation
cargo run -- template render code/rust/struct.hbs --context test.json

# Test helper functions
cargo run -- template test-helpers
```

## Success Criteria
- Templates load and render correctly
- Custom helpers work as expected
- Invalid templates produce clear errors
- Caching improves performance
- Hot-reload works in development

## Known Patterns and Conventions
- Use .hbs extension for templates
- Keep templates focused and modular
- Use partials for repeated elements
- Validate templates at load time
- Cache compiled templates

## Common Pitfalls to Avoid
- Don't put logic in templates
- Avoid deeply nested conditionals
- Don't assume variable presence
- Remember to escape special characters
- Handle whitespace carefully

## Dependencies Required
- handlebars = "5.0"
- serde_json = "1.0"
- heck = "0.4"  # For case conversions
- chrono = "0.4"
- notify = "6.0"  # For hot-reload

## Performance Considerations
- Cache compiled templates
- Lazy load templates on demand
- Use partials to reduce duplication
- Minimize helper complexity
- Consider template size limits

## Extension Points
- Plugin-provided helpers
- Custom template directories
- Remote template repositories
- Template marketplace
- AI-powered template generation

## Confidence Score: 9/10
Well-established patterns with mature library. Handlebars is proven technology with excellent Rust support.